<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="shell" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1999/xhtml"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1998/Math/MathML"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Spring Shell</title>

  <para>The core components of the shell are its plugin model, built-in
  commands, and converters</para>

  <section>
    <title>Plugin Model</title>

    <para>The plugin model is based Spring. Each plugin jar is required to
    contain the file
    <literal>META-INF/spring/spring-shell-plugin.xml</literal>. These files
    will be loaded to bootstrap a Spring
    <interfacename>ApplicationContext</interfacename> when the shell is
    started. The essential boostrapping code that looks for your contributions
    looks like this<programlisting>new ClassPathXmlApplicationContext("classpath*:/META-INF/spring/spring-shell-plugin.xml");</programlisting></para>

    <para> In the <literal>spring-shell-plugin.xml</literal> file you should
    declare the commands and any collaboration objects that support the
    commands actions. An easy way to declare the commands is to use Spring's
    component scanning functionality. </para>

    <para>Here is an example <literal>spring-shell-plugin.xml </literal>that
    from the sample application. </para>

    <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd"&gt;

  &lt;context:component-scan base-package="org.springframework.shell.samples.helloworld.commands" /&gt;

&lt;/beans&gt;</programlisting>

    <para>The commands are Spring components, demarcated as such using the
    <literal>@Component</literal> annotation. For example, the
    <classname>HelloWorldCommands</classname> class from the sample
    application looks like this</para>

    <programlisting language="java">@Component
public class HelloWorldCommands implements CommandMarker {

  // methods with @Cli annotations go here

  // use any Spring annotations for Dependency Injection or other Spring interfaces as required.

}</programlisting>

    <para>One the commands are registered and instantiated by the Spring
    container, they are registered with the core shell parser so that the
    <literal>@Cli</literal> annotationscan be processed. The way the commands
    are identified is through the use of the
    <interfacename>CommandMarker</interfacename> interface. </para>

    <section>
      <title>Converters</title>

      <para>The
      <interfacename>org.springframework.shell.core.Converter</interfacename>
      interface provides the contract to convert the strings that are entered
      in the command to rich Java types passed into the arguments of
      <classname>@Cli</classname>-annotated methods. </para>

      <para>By default converters for common types are registered. These cover
      primitive types (boolean, int, float...) as well as Date, Character, and
      File.</para>

      <para>If you need to register any additional
      <interfacename>Converter</interfacename> instances, register them with
      the Spring container in the
      <classname>spring-shell-plugin.xml</classname> file and they will be
      picked up automatically.</para>
    </section>
  </section>

  <section>
    <title>Built in commands</title>

    <para>There are a few built in commands. Here is a listing of their class
    name and functionality</para>

    <itemizedlist>
      <listitem>
        <para><classname>EssentialCommands</classname> -
        <literal>exit</literal> and <literal>quit</literal> - to exit the
        shell.</para>
      </listitem>

      <listitem>
        <para><classname>HelpCommands</classname> - <literal>help</literal> -
        list all commands and their usage</para>
      </listitem>

      <listitem>
        <para><classname>OsCommands</classname> - the keyword for this command
        is the exclamation point, <literal>!</literal>. After the exclamation
        point you can pass in a unix/windows command string to be
        executed.</para>
      </listitem>
    </itemizedlist>

    <para/>
  </section>
</chapter>
